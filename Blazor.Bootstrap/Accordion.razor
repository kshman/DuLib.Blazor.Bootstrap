@namespace Du.Blazor.Bootstrap
@inherits AddendumItemContainer

<CascadingValue Value="this" IsFixed="true">
	@ChildContent
</CascadingValue>

<div class="@CssClass" id="@Id" @attributes="@UserAttrs">
	@foreach (var item in Items)
	{
		var expanded = AlwaysOpen ? item.GetAcnExpanded() : item == SelectedItem;
		<div class="accordion-item" @attributes="@item.UserAttrs">
			<h2 class="accordion-header">
				<button type="button"
					class="@CssCompose.Join("accordion-button", expanded.IfFalse("collapsed"), item.DisplayClass)"
					data-bs-toggle="collapse"
					data-bs-target="#@item.Id"
					aria-controls="@item.Id"
					aria-expanded="@expanded">
					@item.Text
					@item.Display
				</button>
			</h2>
			<Collapse @ref="item.GetAcnObject()!.Collapse"
				  Class="@CssCompose.Join("accordion-collapse", expanded.IfTrue("show"))"
				  ParentId="@(AlwaysOpen ? null : $"#{Id}")"
				  Id="@item.Id"
				  OnExpanding="HandleOnExpandingAsync"
				  OnExpanded="HandleOnExpandedAsync">
				<div class="@CssCompose.Join("accordion-body", item.CssClass)">
					@(item.Content ?? item.ChildContent)
				</div>
			</Collapse>
		</div>
	}
</div>

@code {
	/// <summary>모서리 없는 모양</summary>
	[Parameter] public bool Flush { get; set; }
	/// <summary>언제나 열려있음</summary>
	[Parameter] public bool AlwaysOpen { get; set; }

	/// <summary>열리려고 할 때 이벤트</summary>
	[Parameter] public EventCallback<ExpandedEventArgs> OnExpanding { get; set; }
	/// <summary>열리고 나서 이벤트</summary>
	[Parameter] public EventCallback<ExpandedEventArgs> OnExpanded { get; set; }

	//
	protected override bool SelectFirst => false; // 처음 아이템이 열리지 않게 함

	//
	private bool _now_transition;

	//
	protected override void OnComponentClass(CssCompose cssc)
	{
		cssc.Add("accordion")
			.Add(Flush, "accordion-flush");
	}

	//
	protected override Task OnAfterFirstRenderAsync()
	{
		if (SelectedItem is not null && _now_transition is false)
			return InternalExpandAsync(SelectedItem);
		return Task.CompletedTask;
	}

	//
	protected override bool ShouldRender() =>
		!_now_transition;

	//
	protected override async Task OnItemAddedAsync(AddendumItem item)
	{
		item.ExtendObject = new AcnExtend();

		if (item == SelectedItem && !_now_transition)
			await InternalExpandAsync(item);
	}

	/// <summary>엽니다</summary>
	/// <param name="id"></param>
	/// <returns></returns>
	public Task ExpandAsync(string id) =>
		InternalExpandAsync(GetItem(id));

	/// <summary>닫아요</summary>
	/// <param name="id"></param>
	/// <returns></returns>
	public Task CollapseAsync(string id) =>
		InternalCollapseAsync(GetItem(id));

	// 열려라
	private Task InternalExpandAsync(AddendumItem? item)
	{
		var collapse = item?.GetAcnCollapse();

		if (collapse is null)
			return Task.CompletedTask;

		_now_transition = true;
		return collapse.ExpandAsync();
	}

	// 닫아라
	private Task InternalCollapseAsync(AddendumItem? item)
	{
		var collapse = item?.GetAcnCollapse();

		if (collapse is null)
			return Task.CompletedTask;

		_now_transition = true;
		return collapse.CollapseAsync();
	}

	// 열릴때
	private async Task HandleOnExpandingAsync(ExpandedEventArgs e)
	{
		_now_transition = true;
		await InvokeOnExpanding(e);
	}

	// 열린다음
	private async Task HandleOnExpandedAsync(ExpandedEventArgs e)
	{
		_now_transition = false;

		var item = GetItem(e.Id);
		if (item?.ExtendObject is null)
		{
			// 아니 이럴수가 있나. 걍 무시
			return;
		}

		if (AlwaysOpen is false && item != SelectedItem)
		{
			item.SetAcnExpanded(false);
			//언제나 열기가 아닐 대 닫는것도 받으려면 이 주석 지우면됨
			//await InvokeOnExpanded(new ExpandedEventArgs(cur.Id, false));
		}

		item.SetAcnExpanded(e.Expanded);
		await InvokeOnExpanded(e);

		await SelectItemAsync(item);
	}

	//
	private Task InvokeOnExpanding(ExpandedEventArgs e) => OnExpanding.InvokeAsync(e);
	private Task InvokeOnExpanded(ExpandedEventArgs e) => OnExpanded.InvokeAsync(e);
}
