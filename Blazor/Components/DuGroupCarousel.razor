@inherits DuGroupBase
@implements IAsyncDisposable
@inject IJSRuntime JS

<div @ref="RootElement"
     @attributes="UserAttributes"
     style="@CssStyle.Result"
     class="@CssClass.Result"
     data-bs-interval="@(Interval is null ? "false" : Interval)"
     data-bs-touch="@(Touch ? "true" : "false")"
     id="@Id">

	@if (Indicators && _items.Count > 0)
	{
		<div class="carousel-indicators">
			@for (var i = 0; i < _items.Count; i++)
			{
				<button class="@_items[i].Active.IfTrue("active")"
				        type="button"
				        data-bs-target="#@Id"
				        data-bs-slide-to="@i"
				        aria-label="Slide @i"
				        aria-current="@_items[i].Active.IfTrue("true")"
				        @key="i">
				</button>
			}
		</div>
	}

	<div class="carousel-inner">
		<CascadingValue Value="this" IsFixed="true">
			@ChildContent
		</CascadingValue>
	</div>

	@if (Controls)
	{
		<button class="carousel-control-prev" type="button" data-bs-target="#@Id" data-bs-slide="prev" id="@($"{Id}_prev")">
			<span class="carousel-control-prev-icon" aria-hidden="true"></span>
			<span class="visually-hidden">Previous</span>
		</button>
		<button class="carousel-control-next" type="button" data-bs-target="#@Id" data-bs-slide="next" id="@($"{Id}_next")">
			<span class="carousel-control-next-icon" aria-hidden="true"></span>
			<span class="visually-hidden">Next</span>
		</button>
	}
</div>

@code {
	[Parameter]
	public bool Dark { get; set; }

	[Parameter]
	public bool Fade { get; set; }

	[Parameter]
	public bool Indicators { get; set; }

	[Parameter]
	public bool Controls { get; set; } = true;

	[Parameter]
	public int? Interval { get; set; } = 5000;

	[Parameter]
	public bool Touch { get; set; } = true;

	[Parameter]
	public CarouselPlay Play { get; set; } = CarouselPlay.Auto;

	[Parameter]
	public CarouselPause Pause { get; set; } = CarouselPause.Hover;

	[Parameter]
	public EventCallback<CarouselSlideEvent> OnBeginSlide { get; set; }

	[Parameter]
	public EventCallback<CarouselSlideEvent> OnEndSlide { get; set; }

	protected override string RootClass => RootClasses.carousel;

	private List<DuCarousel> _items = new();

	private DotNetObjectReference<DuGroupCarousel>? _objref;
	private bool _disposed;

	//
	protected override void OnComponentClass()
	{
		CssClass
			.Add(() => Dark.IfTrue(RootClasses.carousel_dark))
			.Add(() => Fade.IfTrue(RootClasses.carousel_fade));
	}

	//
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		await base.OnAfterRenderAsync(firstRender);

		if (!firstRender || _disposed)
			return;

		var options = new Dictionary<string, object>
		{
			["ride"] = Play switch
			{
				CarouselPlay.Auto => RootClasses.carousel_name,
				CarouselPlay.True => true,
				_ => false
			},
			["pause"] = Pause == CarouselPause.Hover ? RootClasses.hover : false
		};

		_objref ??= DotNetObjectReference.Create(this);
		await JS.InvokeVoidAsync("DUCARS.init", RootElement, _objref, options);
	}

	//
	public void AddItem(DuCarousel item)
	{
		_items.Add(item);

		StateHasChanged();
	}

	//
	public void RemoveItem(DuCarousel item)
	{
		_items.Remove(item);

		if (!_disposed)
			StateHasChanged();
	}

	//
	public virtual Task InvokeOnBeginSlide(CarouselSlideEvent e)
	{
		return OnBeginSlide.InvokeAsync(e);
	}

	//
	public virtual Task InvokeOnEndSlide(CarouselSlideEvent e)
	{
		return OnEndSlide.InvokeAsync(e);
	}

	//
	[JSInvokable("invoke_cars_bs")]
	public async Task HandleBeginSlide(int from, int to, bool isLeft)
	{
		await InvokeOnBeginSlide(new CarouselSlideEvent
		{
			From = from,
			To = to,
			IsLeft = isLeft
		});
	}

	//
	[JSInvokable("invoke_cars_es")]
	public async Task HandleEndSlide(int from, int to, bool isLeft)
	{
		await InvokeOnEndSlide(new CarouselSlideEvent
		{
			From = from,
			To = to,
			IsLeft = isLeft
		});
	}

	//
	public async Task MoveToAsync(int index)
	{
		await JS.InvokeVoidAsync("DUCARS.to", RootElement, index);
	}

	//
	public async Task MovePreviousAsync()
	{
		await JS.InvokeVoidAsync("DUCARS.prev", RootElement);
	}

	//
	public async Task MoveNextAsync()
	{
		await JS.InvokeVoidAsync("DUCARS.next", RootElement);
	}

	//
	public async Task CycleAsync()
	{
		await JS.InvokeVoidAsync("DUCARS.cycle", RootElement);
	}

	//
	public async Task PauseAsync()
	{
		await JS.InvokeVoidAsync("DUCARS.pause", RootElement);
	}

	//
	public async ValueTask DisposeAsync()
	{
		if (_disposed) return;

		try
		{
			await JS.InvokeVoidAsync("DUCARS.disp", RootElement);
		}
		catch (JSDisconnectedException)
		{
	// 그럴 수도 있음
		}

		_objref?.Dispose();

		_disposed = true;
	}
}
