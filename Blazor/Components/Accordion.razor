@inherits ContentItemContainer

<CascadingValue Value="this" IsFixed="true">
	@ChildContent
</CascadingValue>

<div class="@CssClass" id="@Id" @attributes="@UserAttrs">
	@foreach (var item in Items)
	{
		var expanded = AlwaysOpen ? item.AcnExtend!.Expanded : item == SelectedItem;
		<div class="@CssCompose.Join("accordion-item", item.CssClass)" @attributes="@item.UserAttrs">
			<h2 class="accordion-header">
				<button type="button"
					class="@CssCompose.Join("accordion-button", expanded.IfFalse("collapsed"))"
					data-bs-toggle="collapse"
					data-bs-target="#@item.Id"
					aria-controls="@item.Id"
					aria-expanded="@expanded.ToBootStrap()">
					@item.Text
					@item.Display
				</button>
			</h2>
			<Collapse @ref="item.AcnExtend!.Collapse"
				  Class="@CssCompose.Join("accordion-collapse", expanded.IfTrue("show"))"
				  ParentId="@(AlwaysOpen ? null : $"#{Id}")"
				  Id="@item.Id"
				  OnExpanding="HandleOnExpandingAsync"
				  OnExpanded="HandleOnExpandedAsync">
				<div class="accordion-body">
					@(item.Content ?? item.ChildContent)
				</div>
			</Collapse>
		</div>
	}
</div>

@code {
	[Parameter] public bool Flush { get; set; }
	[Parameter] public bool AlwaysOpen { get; set; }

	[Parameter] public EventCallback<ExpandedEventArgs> OnExpanding { get; set; }
	[Parameter] public EventCallback<ExpandedEventArgs> OnExpanded { get; set; }

	//
	protected override bool SelectFirst => false; // 처음 아이템이 열리지 않게 함

	//
	private bool _now_transition;

	//
	protected override void OnComponentClass(CssCompose css)
	{
		css
			.Add("accordion")
			.AddIf(Flush, "accordion-flush");
	}

	//
	protected override Task OnAfterFirstRenderAsync()
	{
		if (SelectedItem is not null && _now_transition is false)
			return InternalExpandAsync(SelectedItem);
		return Task.CompletedTask;
	}

	//
	protected override bool ShouldRender() =>
		!_now_transition;

	//
	protected override async Task OnItemAddedAsync(ContentItem item)
	{
		item.AcnExtend = new AcnExtend();

		if (item == SelectedItem && !_now_transition)
			await InternalExpandAsync(item);
	}

	//
	public Task ExpandAsync(string id) =>
		InternalExpandAsync(GetItem(id));

	//
	public Task CollapseAsync(string id) =>
		InternalCollapseAsync(GetItem(id));

	//
	private Task InternalExpandAsync(ContentItem? item)
	{
		if (item?.AcnExtend?.Collapse is null)
			return Task.CompletedTask;

		_now_transition = true;
		return item.AcnExtend.Collapse.ShowAsync();
	}

	//
	private Task InternalCollapseAsync(ContentItem? item)
	{
		if (item?.AcnExtend?.Collapse is null)
			return Task.CompletedTask;

		_now_transition = true;
		return item.AcnExtend.Collapse.HideAsync();
	}

	//
	private async Task HandleOnExpandingAsync(ExpandedEventArgs e)
	{
		_now_transition = true;
		await InvokeOnExpanding(e);
	}

	//
	private async Task HandleOnExpandedAsync(ExpandedEventArgs e)
	{
		_now_transition = false;

		var item = GetItem(e.Id);
		if (item?.AcnExtend is null)
		{
			// 아니 이럴수가 있나. 걍 무시
			return;
		}

		if (AlwaysOpen is false && item != SelectedItem)
		{
			item.AcnExtend.Expanded = false;
			//언제나 열기가 아닐 대 닫는것도 받으려면 이 주석 지우면됨
			//await InvokeOnExpanded(new ExpandedEventArgs(cur.Id, false));
		}

		item.AcnExtend.Expanded = e.Expanded;
		await InvokeOnExpanded(e);

		await SelectItemAsync(item);
	}

	//
	private Task InvokeOnExpanding(ExpandedEventArgs e) => OnExpanding.InvokeAsync(e);
	private Task InvokeOnExpanded(ExpandedEventArgs e) => OnExpanded.InvokeAsync(e);
}
