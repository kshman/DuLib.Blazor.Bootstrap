@inherits ComponentContainer

<CascadingValue Value="this" IsFixed="true">
	@ChildContent
</CascadingValue>

<div class="@CssClass" id="@Id" @attributes="@UserAttrs">
	@foreach (var item in Items)
	{
		var acn = (ContentItem)item;
		var extend = (AcnExtend)acn.Extend!;
		var expanded = AlwaysOpen ? extend.Expanded : acn == SelectedItem;
		<div class="@CssCompose.Join("accordion-item", acn.CssClass)" @attributes="@acn.UserAttrs">
			<h2 class="accordion-header">
				<button type="button" class="@CssCompose.Join("accordion-button", expanded.IfFalse("collapsed"))"
					data-bs-toggle="collapse" data-bs-target="#@acn.Id" aria-controls="@acn.Id" aria-expanded="@expanded.ToBootStrap()">
					@acn.Text
					@acn.Display
				</button>
			</h2>
			<Collapse @ref="extend.Collapse"
				  Class="@CssCompose.Join("accordion-collapse", expanded.IfTrue("show"))"
				  Parent="@(AlwaysOpen ? null : $"#{Id}")" id="@acn.Id"
				  OnExpanding="HandleOnExpandingAsync"
				  OnExpanded="HandleOnExpandedAsync">
				<div class="accordion-body">
					@(acn.Content ?? acn.ChildContent)
				</div>
			</Collapse>
		</div>
	}
</div>

@code {
	[Parameter] public bool Flush { get; set; }
	[Parameter] public bool AlwaysOpen { get; set; }

	[Parameter] public EventCallback<ExpandedEventArgs> OnExpanding { get; set; }
	[Parameter] public EventCallback<ExpandedEventArgs> OnExpanded { get; set; }

	//
	protected override string CssName => "accordion";
	protected override bool SelectFirst => false; // 처음 아이템이 열리지 않게 함

	//
	private bool _now_transition;

	//
	protected override void OnComponentClass(CssCompose css)
	{
		css.Add(Flush, "accordion-flush");
	}

	//
	protected override Task OnAfterFirstRenderAsync()
	{
		if (SelectedItem is not null && _now_transition is false)
			return InternalExpandAsync(SelectedItem as ContentItem);
		return Task.CompletedTask;
	}

	//
	protected override bool ShouldRender() =>
		!_now_transition;

	//
	protected override async Task OnItemAddedAsync(ComponentItem item)
	{
		var acn = item.ThrowIfConvertFail<ContentItem>();

		acn.Extend = new AcnExtend();

		if (acn == SelectedItem && !_now_transition)
			await InternalExpandAsync(acn);
	}

	//
	public Task ExpandAsync(string id) => 
		InternalExpandAsync(GetItem<ContentItem>(id));

	//
	public Task CollapseAsync(string id) => 
		InternalCollapseAsync(GetItem<ContentItem>(id));

	//
	private Task InternalExpandAsync(ContentItem? acn)
	{
		if (acn?.Extend is not AcnExtend { Collapse: { } } extend)
			return Task.CompletedTask;

		_now_transition = true;
		return extend.Collapse.ShowAsync();
	}

	//
	private Task InternalCollapseAsync(ContentItem? acn)
	{
		if (acn?.Extend is not AcnExtend { Collapse: { } } extend)
			return Task.CompletedTask;

		_now_transition = true;
		return extend.Collapse.HideAsync();
	}

	//
	private async Task HandleOnExpandingAsync(ExpandedEventArgs e)
	{
		_now_transition = true;
		await InvokeOnExpanding(e);
	}

	//
	private async Task HandleOnExpandedAsync(ExpandedEventArgs e)
	{
		_now_transition = false;

		if (GetItem(e.Id) is not ContentItem acn)
		{
			// 아니 이럴수가 있나. 걍 무시
			return;
		}

		if (acn.Extend is not AcnExtend extend)
		{
			// 아니 이럴 수도 없어! 어쩔
			return;
		}

		if (AlwaysOpen is false && SelectedItem is ContentItem cur && cur != acn)
		{
			extend.Expanded = false;
			//언제나 열기가 아닐 대 닫는것도 받으려면 이 주석 지우면됨
			//await InvokeOnExpanded(new ExpandedEventArgs(cur.Id, false));
		}

		extend.Expanded = e.Expanded;
		await InvokeOnExpanded(e);

		await SelectItemAsync(acn);
	}

	//
	private Task InvokeOnExpanding(ExpandedEventArgs e) => OnExpanding.InvokeAsync(e);
	private Task InvokeOnExpanded(ExpandedEventArgs e) => OnExpanded.InvokeAsync(e);
}
