@inherits ComponentContainer

<CascadingValue Value="this" IsFixed="true">
	@ChildContent
</CascadingValue>

<div class="@CssClass" id="@Id" @attributes="@UserAttrs">
	@foreach (var item in Items)
	{
		var acn = (ContentItem)item;
		var prm = (AcnParam)acn.Tag!;
		var expanded = AlwaysOpen ? prm.Expanded : acn == Current;
		<div class="@CssCompose.Join("accordion-item", acn.CssClass)" @attributes="@acn.UserAttrs">
			<h2 class="accordion-header">
				<button type="button" class="@CssCompose.Join("accordion-button", expanded.IfFalse("collapsed"))"
					data-bs-toggle="collapse" data-bs-target="#@acn.Id" aria-controls="@acn.Id" aria-expanded="@expanded.ToBootStrap()">
					@acn.Text
					@acn.Display
				</button>
			</h2>
			<Collapse @ref="((AcnParam)acn.Tag!).Collapse"
				  Class="@CssCompose.Join("accordion-collapse", expanded.IfTrue("show"))"
				  Parent="@(AlwaysOpen ? null : $"#{Id}")" id="@acn.Id"
				  OnExpanded="HandleOnExpandedAsync">
				<div class="accordion-body">
					@(acn.Content ?? acn.ChildContent)
				</div>
			</Collapse>
		</div>
	}
</div>

@code {
	[Parameter] public bool Flush { get; set; }
	[Parameter] public bool AlwaysOpen { get; set; }

	[Parameter] public EventCallback<ExpandedEventArgs> OnExpanding { get; set; }
	[Parameter] public EventCallback<ExpandedEventArgs> OnExpanded { get; set; }

	//
	protected override string CssName => "accordion";
	protected override bool SelectFirst => false;

	//
	private bool _now_transition;

	//
	protected override void OnComponentClass(CssCompose css)
	{
		css.Add(Flush, "accordion-flush");
	}

	//
	protected override void OnAfterFirstRender()
	{
		if (Current is not null && _now_transition is false)
			InternalExpand(Current as ContentItem);
	}

	//
	protected override bool ShouldRender() =>
		!_now_transition;

	//
	protected override void OnItemAdded(ComponentItem item)
	{
		if (item is not ContentItem acn)
		{
			ThrowSupp.MustBeComponent(nameof(item), nameof(ContentItem));
			return; // 널체크 회피
		}

		acn.Tag = new AcnParam();

		if (acn != Current)
			return;

		if (!_now_transition)
			InternalExpand(acn);
	}

	//
	public void Expand(string id) => InternalExpand(GetItem(id) as ContentItem);

	//
	public void Collapse(string id) => InternalCollapse(GetItem(id) as ContentItem);

	//
	private void InternalExpand(ContentItem? acn)
	{
		if (acn?.Tag is not AcnParam { Collapse: { } } param)
			return;

		_now_transition = true;
		InvokeAsync(async () => await param.Collapse.ShowAsync());
	}

	//
	private void InternalCollapse(ContentItem? acn)
	{
		if (acn?.Tag is not AcnParam { Collapse: { } } param)
			return;

		_now_transition = true;
		InvokeAsync(async () => await param.Collapse.HideAsync());
	}

	//
	private async Task TaskHandleOnExpadingAsync(ExpandedEventArgs e)
	{
		_now_transition = true;
		await InvokeOnExpanding(e);
	}

	//
	private async Task HandleOnExpandedAsync(ExpandedEventArgs e)
	{
		_now_transition = false;

		if (GetItem(e.Id) is not ContentItem acn)
		{
			// 아니 이럴수가 있나. 걍 무시
			return;
		}

		var prm = (AcnParam?)acn.Tag;
		if (prm is null)
		{
			// 아니 이럴 수도 없어! 어쩔
			return;
		}

		if (AlwaysOpen is false && Current is ContentItem cur && cur != acn)
		{
			prm.Expanded = false;
			//언제나 열기가 아닐 대 닫는것도 받으려면 이 주석 지우면됨
			//await InvokeOnExpanded(new ExpandedEventArgs(cur.Id, false));
		}

		prm.Expanded = e.Expanded;
		await InvokeOnExpanded(e);

		SelectItem(acn);
	}

	//
	private Task InvokeOnExpanding(ExpandedEventArgs e) => OnExpanding.InvokeAsync(e);
	private Task InvokeOnExpanded(ExpandedEventArgs e) => OnExpanded.InvokeAsync(e);

	//
	internal class AcnParam
	{
		internal bool Expanded { get; set; }
		internal Collapse? Collapse { get; set; }
	}
}
